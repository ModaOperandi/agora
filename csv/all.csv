name,ring,quadrant,isNew,description
"Placeholder","Adopt","Platforms",FALSE,"<p>TBD</p>"
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
"ReasonML","Trial","Languages & Frameworks",FALSE,"<p><a href=""https://reasonml.github.io/"">ReasonML</a> is an alternative syntax to <a href=""http://www.ocaml.org/"">OCaml</a> - a language that features functional, imperative, and object-oriented programming with a compiler that employs static typing and type inference. It was founded by the creator of ReactJS, <a href=""https://github.com/jordwalke"">Jordan Walke</a>, with the backing of Facebook, Bloomberg, and other individual contributors within the open source community.</p>

<h4>Why?</h4>

<p>Reason leverages the power of OCaml's compiler, while providing a familiar syntax, in an effort to create a clean, fast, and effective way to write JS. It provides the ability to create safe and robust frontend applications. </p>

<p>The type system allows us to avoid most runtime errors that waste large portions of time trying to debug, as well as the ability to refactor existing code while keeping the entire application in sync, from container to view.</p>

<p>It's usually difficult to modify someone else's code, or to try and reason (hah!) about a system that you didn't write. This is where the static typing comes in handy the most. In our use case, we just turn data into views, so when we're modifying each other's written code, the type system will guide us; Therefore allowing us to do our jobs quicker, without sacrificing quality.</p>

<h4>JS Interop (how can we interact with existing JS?)</h4>

<p><a href=""https://bucklescript.github.io/docs/en/what-why"">BuckleScript</a> is a fork of OCaml that allows ReasonML or OCaml code to be compiled into JS. It was originally produced by <a href=""https://github.com/bobzhang"">Hongbo Zhang</a> at Bloomberg, and has grown to be its own library and repository, so that others could contribute. It also provides a way to bind to existing JS and incorporate it into a Reason project.</p>

<p>We end up bundling our compiled Reason code, along with all the dependencies we use, with webpack into a compressed and uglified JS file. After that we can import our components into any other JS application, just like any other library.</p>

<h4>React?</h4>

<p>There is an actively supported library, <a href=""https://reasonml.github.io/reason-react/en/"">ReasonReact</a>, that gives users the ability to write React components (and soon <a href=""https://github.com/reasonml/reason-react/pull/351"">hooks</a>) in Reason. This library serves as the backbone of Moda's <a href=""https://github.com/modaoperandi/not-elixir"">display library</a>. It provides a way to render components written in plain JS, as well as a way to export components written in Reason for use in the JS world. The hooks PR linked above also includes support for the new context API in React, which allows global data storage and retrieval.</p>

<h4>Drawbacks</h4>

<ul>
<li><a href=""https://github.com/BuckleScript/bucklescript/issues/1187"">bs-platform</a>, the BuckleScript runtime, is bundled by webpack with our code. They are <a href=""https://bucklescript.github.io/blog/2018/12/05/release-4-0-8"">working on a solution</a> to separate the runtime and the standard library, so that generated JS can be shipped as a library without the need of a bundler.</li>
<li>The learning curve is steep. People coming with experience in <a href=""https://www.typescriptlang.org"">TypeScript</a> or another strongly typed language will have a way easier time adjusting, otherwise it can be quite challenging.</li>
<li>Smaller audience for problems on Stack Overflow or other forums.</li>
<li>Compared to TypeScript, adoption is less, so there are fewer bindings to existing JS libraries.</li>
</ul>

<h4>Positives</h4>

<ul>
<li>Build times are extremely fast. I use BuckleScript to compile all the <strong>*.re</strong> files into <strong>*.bs.js</strong>, which is taken by Webpack and bundled up to be required in an index.html file that I load in my browser. Compiling the Reason to JS takes roughly 30 to 40 milliseconds on average. Writing code &amp; checking the functionality or the design almost instantly is pretty nice.</li>
<li>Refactoring is very easy. Due to the static typing, changing how data enters a component or removing code from an existing component becomes very intuitive. The compiler will point out every instance of how that code was being used, and what it is trying to compile now.</li>
<li><a href=""https://reasonml.github.io/docs/en/pattern-matching"">Pattern matching!</a> It is a <a href=""https://github.com/tc39/proposal-pattern-matching"">very early proposal</a> in JavaScript land, but we have it right now in Reason! In addition to being more readable, pattern matching allows for <a href=""http://hackage.haskell.org/package/exhaustive-1.1.6/docs/Control-Exhaustive.html"">exhaustive checks</a> of all the ways data could be represented, and the compiler enforces it through the type system.</li>
<li>The type system has been a great benefit to us when writing code. We avoid annoying runtime bugs that are caught by the compiler early on from simple mistakes. I feel assured knowing that the code being compiled will run and not break (assuming our components are rendered correctly!)</li>
<li>A large company in Facebook backs it and uses it currently in production.</li>
</ul>"
"Scala","Trial","Languages & Frameworks",FALSE,"<ul>
<li><p>Language features (mostly used)</p>

<ul>
<li>immutability by default</li>
<li><p>null safety (kind of) 
```scala
 case class Point(x : Int, y : Int)
 val a : Point = null //danger
 a.x //OOPS, NPE</p>

<p>val b : Option[Point] = Option(javaFunctionReturningPoint())</p>

<p>b.map{ point =&gt; 
    //safely use point
 }</p>

<p>```</p></li>
<li>type inference
<code>scala
val a = ""hello world""
val b : String = ""hello world""
</code></li>
<li>data types
<code>scala
case class Point(x : int, y : Int)
</code></li>
<li><p>Pattern matching 
```scala
val point = Point(34, 65)
point match {
case Point(x, y) =&gt; //x = 34 y = 65
}
def calcSomePoint() : Point
val Point(x, y) = calcSomePoint()
//values x and y is available here</p>

<p>val ages = List(3, 6, 43, 1, 0)
ages match {
case head :: tail =&gt; //head : Int 
//tail : List[Int]
case Nil =&gt; //list is empty
}
```</p></li>
<li>for-comprehansion 
```scala
def callService1 : Future[Result]
def callService2 : Futire[Result]</li>
</ul>

<p>val results : Futire[(Result, Result)] = (for{
res1 &lt;- callService1
res2 &lt;- callService2
} yield (res1, res2))
```</p>

<ul>
<li>higher order functions 
```scala 
def double(x) = x * 2</li>
</ul>

<p>val numbers : List(1, 2, 3)
numbers.map(double)
//List(2,4,6)
```</p>

<ul>
<li>sealed traits
```scala
sealed trait Direction
case object North extends Direction
case object South extends Direction
case object West extends Direction
case object East extends Direction
case class Unknown(name : String)</li>
</ul>

<p>val dir : Direction = calcDirection()
//following is exhaustive pattern matching
dir match {
  case North =&gt;
  case South =&gt;
  case West =&gt;
  case East =&gt;
  case Unknown(unknownDirection) =&gt; println(s""you shell not pass $unknownDirection"")
}
```</p>

<ul>
<li><p>Algepraic Data Types (ADT)</p>

<ul>
<li>sealed traits (sums)</li>
<li>case clusses (products)</li>
</ul></li>
<li><p>inplicits (very low level language feature, many usefull things may be implemented using it)</p>

<ul>
<li>type classes
```scala
//type class
trait Addable[T] {
def add(left: T, right: T): T
}</li>
</ul>

<p>def add1<a href=""left: A, right: A"">A: Addable</a>: A = {
 implicitly[Addable[A]].add(left, right)
}
//add2 is identical to add1, just more explicit syntax
def add2<a href=""left: A, right: A"">A</a>(implicit Addable: Addable[A]): A = {
 Addable.add(left, right)
}</p>

<p>implicit object IntAdder extends Addable[Int] {
 override def add(left: Int, right: Int): Int = left + right
}</p>

<p>add2(1, 3) //4</p>

<p>implicit object StringAdder extends Addable[String] {
 override def add(left: String, right: String): String = s""$left $right""
}
add1(""one"", ""two"") //""one two""</p>

<p>add2(Point(1,3), Point(3,5)) // compilation Error, no typeclass implementation for Addable[Point]
```</p></li>
<li><p>Standard library </p>

<ul>
<li>powerfull collections framework </li>
<li>Scala futures</li>
</ul></li>
<li><p>Scala and Pure FP</p>

<ul>
<li>Cats</li>
<li>ZIO</li>
<li>take a look into effects management, referential transparency and function purity and totality</li>
</ul></li>
<li><p>Frameworks</p></li>
<li>Play Framework, Akka HTTP, Http4S (RESTful HTTP)</li>
<li>Anorm, Slick, Doobie (JDBC wrappers, ORM)</li>
<li>Akka (Actors framework, inspired by Erlang, very low level for distributed, concurrent applications)</li>
<li>Akka Streams, FS2, Monix (reactive streams, pull, push or hibrid design)</li>
<li>Circe (Json encoder/decoder based on shapless)</li>
<li>Scalacheck (very poerfull concept of property testing)</li>
<li>Scalatest</li>
<li>also all Java libraries are available including Spring, Java SDK etc, but not recommended to use, because of mutable nature</li>
</ul></li>
</ul>"
"Kotlin","Assess","Languages & Frameworks",FALSE,"<p>Here's a good lecture with comparison overview: <a href=""https://www.youtube.com/watch?v=MsMejigb1Zk"">Kotlin vs Scala</a></p>

<p>Here are some lectures from Google I/O to get some idea about Kotlin:</p>

<p><a href=""https://www.youtube.com/watch?v=X1RVYt2QKQE"">Introduction to Kotlin (Google I/O '17)</a></p>

<p><a href=""https://www.youtube.com/watch?v=6P20npkvcb8"">How to Kotlin - from the Lead Kotlin Language Designer (Google I/O '18)</a> </p>

<p>Here are main arguments/advantages of Kotlin over Scala</p>

<ol>
<li><p>Kotlin design is simpler then Scala design - allowing flatter learning curve.</p></li>
<li><p>Kotlin has high level of interop with Java:</p>

<ul>
<li><p>Existing battle-checked Java frameworks can be leveraged directly from Kotlin.</p></li>
<li><p>Code written in Kotlin can be used directly from Java. Less risky to introduce Kotlin with an option to go back to Java at any moment.</p></li>
<li><p>Existing codebase in Java could be converted to Kotlin at almost zero cost (even with one click in IntelliJ IDEA).</p></li>
<li><p>Easy to adopt at other areas, like QA automation.</p></li>
</ul></li>
<li><p>Kotlin is one of two (golang as well) industrial languages that have coroutines.</p></li>
<li><p>Kotlin is multiplatform (implemented by vendor) - could be used for wide variety of tasks even where heavy JVM is not applicable.</p></li>
<li><p>Kotlin outside of Android is pretty fresh - should help to get the attention of talented engineers and define Moda Operandi as a technology driven company.</p></li>
<li><p>Kotlin is newest in JVM space - it has opportunity for developers to make an impact by contributing more in open source.</p></li>
</ol>

<p>Here are some main Kotlin features:
- immutability control
   ```kotlin
   val a = ""some string""</p>

<p>a = ""some other string"" // won't compile a is immutable
   <code>
- true null safety
</code>kotlin
   val a: String = null // won't compile String is not nullable type</p>

<p>val b: String? = null // this is fine String? is nullable</p>

<p>val len = b.length // this won't compile b needs to be checked for null value first</p>

<p>if (b != null) {
      val len = b.length // this is fine b is smartcasted to String type 
   }
   <code>
- type inference
</code>kotlin
   val a = ""some string"" // a type is inferred as String
   val b: String = ""some other string"" // explicit type info is fine too
   <code>
- data types
</code>kotlin
   data class Point(val x: Int, val y: Int) // class with two properties and equality
   <code>
- extension functions
</code>kotlin
   fun MutableList<Int>.swap(index1: Int, index2: Int) { // this is extension function to MutableList
      val tmp = this[index1] // 'this' corresponds to the list
      this[index1] = this[index2]
      this[index2] = tmp
   }</p>

<p>val l = mutableListOf(1, 2, 3)
   l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'
   <code>
- function types
</code>kotlin
   fun <T, R> Collection<T>.fold(
      initial: R, 
      combine: (acc: R, nextElement: T) -> R // function type here
   ): R {
      var accumulator: R = initial
      for (element: T in this) {
         accumulator = combine(accumulator, element)
      }
      return accumulator
   }</p>

<p>val items = listOf(1, 2, 3, 4, 5)</p>

<p>val joinedToString = items.fold(""Elements:"", { acc, i -> acc + "" "" + i }) // lambda function passed here</p>

<p>val product = items.fold(1, Int::times) // function reference passed here
   <code>
- sealed classes with (very) limited pattern matching
</code>kotlin
   sealed class Expr
   data class Const(val number: Double) : Expr()
   data class Sum(val e1: Expr, val e2: Expr) : Expr()
   object NotANumber : Expr()</p>

<p>fun eval(expr: Expr): Double = when(expr) {
      is Const -> expr.number
      is Sum -> eval(expr.e1) + eval(expr.e2)
      NotANumber -> Double.NaN
      // the <code>else</code> clause is not required because we've covered all the cases
   }
   <code>
- coroutines
</code>kotlin
   suspend fun workload(n: Int): Int { // may be executed as suspendable lightweight thread - coroutine
      delay(1000)
      return n
   }```
- all same libraries and frameworks from Java are available with full interop
- there's a lot of work going on at kotlinx libraries space - these libraries are truly multiplatform
- libraries built specifically for Kotlin: Ktor, Koin and some nice DSL addons for existing libraries usable from Kotlin</p>"
"Placeholder","Hold","Tools",FALSE,"<p>TBD</p>"
=======
=======
>>>>>>> Using ReasonML for our frontend applications (#13)
=======
>>>>>>> Recommend Terraform over CloudFormation
"Terraform","Trial","Tools",FALSE,"<p>Moda should be capturing infrastructure assets in committed code (<a href="https://www.hashicorp.com/resources/what-is-infrastructure-as-code">why it is important</a>). Current thinking is that it is superior to <a href="#cloudformation">CloudFormation</a> for the following reasons:</p>

<ol>
<li>Terraform is multi-service. This does not mean that the same Terraform resource can be deployed indiscriminately across different clouds. But it does mean that resources across multiple cloud providers (or any provider, really) can be captured in Terraform - and thus be captured in the same workflow, pipelines, etc.</li>
<li>Terraform uses the provider's APIs. As a result, Terraform - which can model anything available via the API - will always be ahead of CloudFormation in supported resources.</li>
</ol>"
"Placeholder","Assess","Languages & Frameworks",FALSE,"<p>TBD</p>"
"CloudFormation","Hold","Tools",FALSE,"<p>Moda should be capturing infrastructure assets in committed code (<a href="https://www.hashicorp.com/resources/what-is-infrastructure-as-code">why it is important</a>). CloudFormation is the AWS-native way to do IaC. Please see commentary on <a href="#terraform">Terraform</a> for reasons why CloudFormation is not recommended.</p>"
<<<<<<< HEAD
>>>>>>> Recommend Terraform over CloudFormation
=======
=======
=======
>>>>>>> Recommend Terraform over CloudFormation
"ReasonML","Trial","Languages & Frameworks",FALSE,"<p><a href=""https://reasonml.github.io/"">ReasonML</a> is an alternative syntax to <a href=""http://www.ocaml.org/"">OCaml</a> - a language that features functional, imperative, and object-oriented programming with a compiler that employs static typing and type inference. It was founded by the creator of ReactJS, <a href=""https://github.com/jordwalke"">Jordan Walke</a>, with the backing of Facebook, Bloomberg, and other individual contributors within the open source community.</p>

<h4>Why?</h4>

<p>Reason leverages the power of OCaml's compiler, while providing a familiar syntax, in an effort to create a clean, fast, and effective way to write JS. It provides the ability to create safe and robust frontend applications. </p>

<p>The type system allows us to avoid most runtime errors that waste large portions of time trying to debug, as well as the ability to refactor existing code while keeping the entire application in sync, from container to view.</p>

<p>It's usually difficult to modify someone else's code, or to try and reason (hah!) about a system that you didn't write. This is where the static typing comes in handy the most. In our use case, we just turn data into views, so when we're modifying each other's written code, the type system will guide us; Therefore allowing us to do our jobs quicker, without sacrificing quality.</p>

<h4>JS Interop (how can we interact with existing JS?)</h4>

<p><a href=""https://bucklescript.github.io/docs/en/what-why"">BuckleScript</a> is a fork of OCaml that allows ReasonML or OCaml code to be compiled into JS. It was originally produced by <a href=""https://github.com/bobzhang"">Hongbo Zhang</a> at Bloomberg, and has grown to be its own library and repository, so that others could contribute. It also provides a way to bind to existing JS and incorporate it into a Reason project.</p>

<p>We end up bundling our compiled Reason code, along with all the dependencies we use, with webpack into a compressed and uglified JS file. After that we can import our components into any other JS application, just like any other library.</p>

<h4>React?</h4>

<p>There is an actively supported library, <a href=""https://reasonml.github.io/reason-react/en/"">ReasonReact</a>, that gives users the ability to write React components (and soon <a href=""https://github.com/reasonml/reason-react/pull/351"">hooks</a>) in Reason. This library serves as the backbone of Moda's <a href=""https://github.com/modaoperandi/not-elixir"">display library</a>. It provides a way to render components written in plain JS, as well as a way to export components written in Reason for use in the JS world. The hooks PR linked above also includes support for the new context API in React, which allows global data storage and retrieval.</p>

<h4>Drawbacks</h4>

<ul>
<li><a href=""https://github.com/BuckleScript/bucklescript/issues/1187"">bs-platform</a>, the BuckleScript runtime, is bundled by webpack with our code. They are <a href=""https://bucklescript.github.io/blog/2018/12/05/release-4-0-8"">working on a solution</a> to separate the runtime and the standard library, so that generated JS can be shipped as a library without the need of a bundler.</li>
<li>The learning curve is steep. People coming with experience in <a href=""https://www.typescriptlang.org"">TypeScript</a> or another strongly typed language will have a way easier time adjusting, otherwise it can be quite challenging.</li>
<li>Smaller audience for problems on Stack Overflow or other forums.</li>
<li>Compared to TypeScript, adoption is less, so there are fewer bindings to existing JS libraries.</li>
</ul>

<h4>Positives</h4>

<ul>
<li>Build times are extremely fast. I use BuckleScript to compile all the <strong>*.re</strong> files into <strong>*.bs.js</strong>, which is taken by Webpack and bundled up to be required in an index.html file that I load in my browser. Compiling the Reason to JS takes roughly 30 to 40 milliseconds on average. Writing code &amp; checking the functionality or the design almost instantly is pretty nice.</li>
<li>Refactoring is very easy. Due to the static typing, changing how data enters a component or removing code from an existing component becomes very intuitive. The compiler will point out every instance of how that code was being used, and what it is trying to compile now.</li>
<li><a href=""https://reasonml.github.io/docs/en/pattern-matching"">Pattern matching!</a> It is a <a href=""https://github.com/tc39/proposal-pattern-matching"">very early proposal</a> in JavaScript land, but we have it right now in Reason! In addition to being more readable, pattern matching allows for <a href=""http://hackage.haskell.org/package/exhaustive-1.1.6/docs/Control-Exhaustive.html"">exhaustive checks</a> of all the ways data could be represented, and the compiler enforces it through the type system.</li>
<li>The type system has been a great benefit to us when writing code. We avoid annoying runtime bugs that are caught by the compiler early on from simple mistakes. I feel assured knowing that the code being compiled will run and not break (assuming our components are rendered correctly!)</li>
<li>A large company in Facebook backs it and uses it currently in production.</li>
</ul>"
"Placeholder","Assess","Tools",FALSE,"<p>TBD</p>"
<<<<<<< HEAD
>>>>>>> Using ReasonML for our frontend applications (#13)
<<<<<<< HEAD
>>>>>>> Using ReasonML for our frontend applications (#13)
=======
=======
=======
"Terraform","Trial","Tools",FALSE,"<p>Moda should be capturing infrastructure assets in committed code (<a href="https://www.hashicorp.com/resources/what-is-infrastructure-as-code">why it is important</a>). Current thinking is that it is superior to <a href="#cloudformation">CloudFormation</a> for the following reasons:</p>

<ol>
<li>Terraform is multi-service. This does not mean that the same Terraform resource can be deployed indiscriminately across different clouds. But it does mean that resources across multiple cloud providers (or any provider, really) can be captured in Terraform - and thus be captured in the same workflow, pipelines, etc.</li>
<li>Terraform uses the provider's APIs. As a result, Terraform - which can model anything available via the API - will always be ahead of CloudFormation in supported resources.</li>
</ol>"
"Placeholder","Assess","Languages & Frameworks",FALSE,"<p>TBD</p>"
"CloudFormation","Hold","Tools",FALSE,"<p>Moda should be capturing infrastructure assets in committed code (<a href="https://www.hashicorp.com/resources/what-is-infrastructure-as-code">why it is important</a>). CloudFormation is the AWS-native way to do IaC. Please see commentary on <a href="#terraform">Terraform</a> for reasons why CloudFormation is not recommended.</p>"
>>>>>>> Recommend Terraform over CloudFormation
>>>>>>> Recommend Terraform over CloudFormation
>>>>>>> Recommend Terraform over CloudFormation
"Placeholder","Hold","Techniques",FALSE,"<p>TBD</p>"
